package auth

import (
	"errors"
	"fmt"
	"net/http"
	"net/url"

	"github.com/cisco-eti/sre-go-helloworld/pkg/idpadapter"
	"github.com/cisco-eti/sre-go-helloworld/pkg/models"
)

const fakeState = "123" // this should be generated per request

func newStateString() string {
	return fakeState
}

func validateState(s string) error {
	// make sure to validate the state matches what was generated by
	// LoginRedirectHandler()
	if s == fakeState {
		return nil
	}

	return errors.New(fmt.Sprintf("%s != %s", s, fakeState))
}

// LoginRedirectHandler will redirect to the login page for the 3rd party IDP
func (a *Auth) LoginRedirectHandler(w http.ResponseWriter, r *http.Request) {
	state := newStateString()
	idpLoginLink := a.idpAdapter.AuthCodeURL(state, "", idpadapter.LoginAuthFlow)
	http.Redirect(w, r, idpLoginLink, http.StatusTemporaryRedirect)
}

// LoginExchangeHandler will accept a code and exchange it for access and id
// tokens
func (a *Auth) LoginExchangeHandler(w http.ResponseWriter, r *http.Request) {
	err := validateState(r.URL.Query().Get("state"))
	if err != nil {
		http.Error(w, "bad state: "+err.Error(), http.StatusBadRequest)
		return
	}

	code := r.URL.Query().Get("code")
	identity, err := a.idpAdapter.ExchangeCodeAndVerifyTokens(r.Context(), code,
		"", idpadapter.LoginAuthFlow)
	if err != nil {
		http.Error(w, err.Error(), http.StatusUnauthorized)
		return
	}

	// if successful, lookup the user based on the idp's UserID. if the user
	// doesn't already exist, maybe fail? create an explicit "new user signup"
	// flow using the `idpadapter.SignupAuthFlow` enum? alternatively, the new
	// user creation could be implicit -> login without a matching user creates
	// a new one, login with a matching user creates a new session?

	var user models.User
	q := a.db.
		Where(&models.User{
			IDPUserID: identity.UserID,
			IDPIssuer: identity.Issuer,
		}).
		Find(&user)
	if q.Error != nil {
		http.Error(w, q.Error.Error(), http.StatusUnauthorized)
		return
	}
	if q.RowsAffected == 0 {
		// no user found. implicitly create new user? or fail and require explicit
		// "signup"? you decide.

		// implicitly create like this
		user = models.User{
			Name:      identity.Name,
			Email:     identity.Email,
			IDPUserID: identity.UserID,
			IDPIssuer: identity.Issuer,
		}
		q = a.db.Create(&user)
		if q.Error != nil {
			http.Error(w, q.Error.Error(), http.StatusUnauthorized)
			return
		}

		// or require explicit signup and do this
		//http.Error(w, "user not found. please signup", http.StatusUnauthorized)
		//return
	}

	q = a.db.Create(&models.Session{
		UserID:      user.ID,
		AccessToken: identity.AccessToken,
		IDToken:     identity.IDToken,
	})
	if q.Error != nil {
		http.Error(w, q.Error.Error(), http.StatusUnauthorized)
		return
	}

	fmt.Fprintf(w, "%+v %+v %+v %+v %+v %+v %+v %+v",
		identity.UserID,
		identity.Name,
		identity.Email,
		identity.Issuer,
		identity.IDToken,
		identity.AccessToken,
		identity.AccessTokenIssuedAt,
		identity.AccessTokenExpiresAt,
	)
}

// LogoutHandler will log the user out of the 3rd party idp
func (a *Auth) LogoutHandler(w http.ResponseWriter, r *http.Request) {
	params := url.Values{}

	// this specific example will log users out of okta. another idp might
	// require different query params

	// lookup the IDToken based on Authorization Header AccessToken
	idToken := "id_token"

	params.Add("id_token_hint", idToken)
	params.Add("post_logout_redirect_uri", "http://localhost:8080")

	idpLogoutLink := a.idpAdapter.LogoutLink(params)
	http.Redirect(w, r, idpLogoutLink, http.StatusTemporaryRedirect)
}
